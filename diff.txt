1c1,3
< /* TI ADS1X1X ADC
---
> /*
>  * Copyright (c) 2021 Jackychen
>  * Copyright (c) 2021 Jason Kridner, BeagleBoard.org Foundation
3c5
<  * Copyright (c) 2021 Facebook, Inc
---
>  * Based partially on adc_mcp320x.c
8,21c10
< #include <stdbool.h>
< #include <zephyr/device.h>
< #include <zephyr/devicetree.h>
< #include <zephyr/drivers/adc.h>
< #include <zephyr/logging/log.h>
< #include <zephyr/drivers/i2c.h>
< #include <zephyr/kernel.h>
< #include <zephyr/sys/byteorder.h>
< #include <zephyr/sys/util.h>
< 
< #define ADC_CONTEXT_USES_KERNEL_TIMER
< #include "adc_context.h"
< 
< LOG_MODULE_REGISTER(ADS1X1X, CONFIG_ADC_LOG_LEVEL);
---
> #define DT_DRV_COMPAT ti_ads1115
23,38c12,21
< #define ADS1X1X_CONFIG_OS BIT(15)
< #define ADS1X1X_CONFIG_MUX(x) ((x) << 12)
< #define ADS1X1X_CONFIG_PGA(x) ((x) << 9)
< #define ADS1X1X_CONFIG_MODE BIT(8)
< #define ADS1X1X_CONFIG_DR(x) ((x) << 5)
< #define ADS1X1X_CONFIG_COMP_MODE BIT(4)
< #define ADS1X1X_CONFIG_COMP_POL BIT(3)
< #define ADS1X1X_CONFIG_COMP_LAT BIT(2)
< #define ADS1X1X_CONFIG_COMP_QUE(x) (x)
< 
< enum ads1x1x_reg {
< 	ADS1X1X_REG_CONV = 0x00,
< 	ADS1X1X_REG_CONFIG = 0x01,
< 	ADS1X1X_REG_LO_THRESH = 0x02,
< 	ADS1X1X_REG_HI_THRESH = 0x03,
< };
---
> #include <drivers/adc.h>
> #include <drivers/gpio.h>
> #include <drivers/i2c.h>
> #include <kernel.h>
> #include <logging/log.h>
> #include <sys/byteorder.h>
> #include <sys/util.h>
> #include <zephyr.h>
> #include <device.h>
> #include <math.h>
40,49c23,24
< enum {
< 	ADS1X15_CONFIG_MUX_DIFF_0_1 = 0,
< 	ADS1X15_CONFIG_MUX_DIFF_0_3 = 1,
< 	ADS1X15_CONFIG_MUX_DIFF_1_3 = 2,
< 	ADS1X15_CONFIG_MUX_DIFF_2_3 = 3,
< 	ADS1X15_CONFIG_MUX_SINGLE_0 = 4,
< 	ADS1X15_CONFIG_MUX_SINGLE_1 = 5,
< 	ADS1X15_CONFIG_MUX_SINGLE_2 = 6,
< 	ADS1X15_CONFIG_MUX_SINGLE_3 = 7,
< };
---
> LOG_MODULE_REGISTER(ads1115, CONFIG_ADC_LOG_LEVEL);
> //LOG_MODULE_REGISTER(ads1115, LOG_LEVEL_DBG);
51,71c26,28
< enum {
< 	/* ADS111X, ADS101X samples per second */
< 	/* 8, 128 samples per second */
< 	ADS1X1X_CONFIG_DR_8_128 = 0,
< 	/* 16, 250 samples per second */
< 	ADS1X1X_CONFIG_DR_16_250 = 1,
< 	/* 32, 490 samples per second */
< 	ADS1X1X_CONFIG_DR_32_490 = 2,
< 	/* 64, 920 samples per second */
< 	ADS1X1X_CONFIG_DR_64_920 = 3,
< 	/* 128, 1600 samples per second (default) */
< 	ADS1X1X_CONFIG_DR_128_1600 = 4,
< 	/* 250, 2400 samples per second */
< 	ADS1X1X_CONFIG_DR_250_2400 = 5,
< 	/* 475, 3300 samples per second */
< 	ADS1X1X_CONFIG_DR_475_3300 = 6,
< 	/* 860, 3300 samples per second */
< 	ADS1X1X_CONFIG_DR_860_3300 = 7,
< 	/* Default data rate */
< 	ADS1X1X_CONFIG_DR_DEFAULT = ADS1X1X_CONFIG_DR_128_1600
< };
---
> /* TODO: this should change to use the interrupt line */
> #define ADC_CONTEXT_USES_KERNEL_TIMER
> #include "adc_context.h"
73,86c30
< enum {
< 	/* +/-6.144V range = Gain 2/3 */
< 	ADS1X1X_CONFIG_PGA_6144 = 0,
< 	/* +/-4.096V range = Gain 1 */
< 	ADS1X1X_CONFIG_PGA_4096 = 1,
< 	/* +/-2.048V range = Gain 2 (default) */
< 	ADS1X1X_CONFIG_PGA_2048 = 2,
< 	/* +/-1.024V range = Gain 4 */
< 	ADS1X1X_CONFIG_PGA_1024 = 3,
< 	/* +/-0.512V range = Gain 8 */
< 	ADS1X1X_CONFIG_PGA_512 = 4,
< 	/* +/-0.256V range = Gain 16 */
< 	ADS1X1X_CONFIG_PGA_256 = 5
< };
---
> #define ADS1115_RESOLUTION 16U
88,90c32,120
< enum {
< 	ADS1X1X_CONFIG_MODE_CONTINUOUS = 0,
< 	ADS1X1X_CONFIG_MODE_SINGLE_SHOT = 1,
---
> #define ADS1115_REG_CONVERSION		0x00
> #define ADS1115_REG_CONFIG		0x01
> #define ADS1115_REG_LO_TH		0x02
> #define ADS1115_REG_HI_TH		0x03
> 
> #define ADS1115_NUM_CHANNELS	4
> 
> enum average_method {
> 	RMS = 0,
> 	MEAN = 1,
> };
> 
> #define _B(n)		( 1<<(n) )
> #define _M(l)		( _B(l)-1 )
> #define _BM(o, l)	( _M(l)<<(o) )
> #define _BP(x, o, l)	( ((x)&_M(l)) << (o) )
> #define _BG(x, o, l)	( ((x)>>(o)) & _M(l) )
> #define _BS(y, x, o, l) \
> 	( y = ((y) &~ _BM(o,l)) | _BP(x,o,l) )
> 
> #define ADS1115_CFG_OS_GET() _BG(data->config_reg, 15, 1)
> #define ADS1115_CFG_OS_SET(x) _BS(data->config_reg, x, 15, 1)
> #define ADS1115_CFG_MUX_GET() _BG(data->config_reg, 12, 3)
> #define ADS1115_CFG_MUX_SET(x) _BS(data->config_reg, x, 12, 3)
> #define ADS1115_CFG_PGA_GET() _BG(data->config_reg, 9, 3)
> #define ADS1115_CFG_PGA_SET(x) _BS(data->config_reg, x, 9, 3)
> #define ADS1115_CFG_MODE_GET() _BG(data->config_reg, 8, 1)
> #define ADS1115_CFG_MODE_SET(x) _BS(data->config_reg, x, 8, 1)
> #define ADS1115_CFG_DR_GET() _BG(data->config_reg, 5, 3)
> #define ADS1115_CFG_DR_SET(x) _BS(data->config_reg, x, 5, 3)
> #define ADS1115_CFG_CM_GET() _BG(data->config_reg, 4, 1)
> #define ADS1115_CFG_CM_SET(x) _BS(data->config_reg, x, 4, 1)
> #define ADS1115_CFG_CP_GET() _BG(data->config_reg, 3, 1)
> #define ADS1115_CFG_CP_SET(x) _BS(data->config_reg, x, 3, 1)
> #define ADS1115_CFG_CL_GET() _BG(data->config_reg, 2, 1)
> #define ADS1115_CFG_CL_SET(x) _BS(data->config_reg, x, 2, 1)
> #define ADS1115_CFG_CQ_GET() _BG(data->config_reg, 0, 2)
> #define ADS1115_CFG_CQ_SET(x) _BS(data->config_reg, x, 0, 2)
> 
> struct ads1115_config {
> 	struct i2c_dt_spec		bus;
> 	struct gpio_dt_spec		int_gpio;
> 	bool				continuous_mode;
> 	enum average_method		avg_method;
> 	uint16_t			threshold;
> };
> 
> struct ads1115_data {
> 	const struct ads1115_config *	cfg;
> 	struct adc_context		ctx;
> 	const struct device *		dev;
> 	uint16_t *			buffer;
> 	uint16_t *			repeat_buffer;
> 	struct k_thread			thread;
> 	struct k_sem			sem;
> 	uint16_t			config_reg;
> 	uint8_t				seq_channels;
> 	uint8_t				differential;
> 	bool				active;
> 	uint8_t				active_channel;
> 	uint16_t			oversampling;
> 
> 	struct gpio_callback		gpio_cb;
> 
> 	K_KERNEL_STACK_MEMBER(stack,
> 			CONFIG_ADC_ADS1115_ACQUISITION_THREAD_STACK_SIZE);
> };
> 
> static int ads1115_init(const struct device *dev);
> static int ads1115_channel_setup(const struct device *dev,
> 				 const struct adc_channel_cfg *channel_cfg);
> static int ads1115_read(const struct device *dev,
> 			const struct adc_sequence *sequence);
> static int ads1115_read_async(const struct device *dev,
> 			      const struct adc_sequence *sequence,
> 			      struct k_poll_signal *async);
> 
> static int ads1115_reg_write(struct ads1115_data * data, uint8_t reg, uint16_t * val);
> static int ads1115_reg_read(struct ads1115_data * data, uint8_t reg, uint16_t * val);
> static int ads1115_chan_change_with_start_conversion(struct ads1115_data * data, uint8_t channel);
> static int ads1115_once_conversion_status_get(struct ads1115_data * data, int * status);
> 
> static const struct adc_driver_api ads1115_api_funcs = {
> 	.channel_setup = ads1115_channel_setup,
> 	.read = ads1115_read,
> #ifdef CONFIG_ADC_ASYNC
> 	.read_async = ads1115_read_async,
> #endif
> 	.ref_internal = 4096,
93,98c123,126
< enum {
< 	/* Traditional comparator with hysteresis (default) */
< 	ADS1X1X_CONFIG_COMP_MODE_TRADITIONAL = 0,
< 	/* Window comparator */
< 	ADS1X1X_CONFIG_COMP_MODE_WINDOW = 1
< };
---
> static int ads1115_channel_setup(const struct device * dev,
> 				 const struct adc_channel_cfg * channel_cfg)
> {
> 	/* const struct ads1115_config * config = dev->config; */
100,105c128,132
< enum {
< 	/* ALERT/RDY pin is low when active (default) */
< 	ADS1X1X_CONFIG_COMP_POLARITY_ACTIVE_LO = 0,
< 	/* ALERT/RDY pin is high when active */
< 	ADS1X1X_CONFIG_COMP_POLARITY_ACTIVE_HI = 1
< };
---
> 	/* TODO */
> 	if (channel_cfg->gain != ADC_GAIN_1) {
> 		LOG_ERR("unsupported channel gain '%d'", channel_cfg->gain);
> 		return -ENOTSUP;
> 	}
107,112c134,138
< enum {
< 	/* Non-latching comparator (default) */
< 	ADS1X1X_CONFIG_COMP_NON_LATCHING = 0,
< 	/* Latching comparator */
< 	ADS1X1X_CONFIG_COMP_LATCHING = 1
< };
---
> 	if (channel_cfg->reference != ADC_REF_INTERNAL) {
> 		LOG_ERR("unsupported channel reference '%d'",
> 			channel_cfg->reference);
> 		return -ENOTSUP;
> 	}
114,123c140,145
< enum {
< 	/* Assert ALERT/RDY after one conversions */
< 	ADS1X1X_CONFIG_COMP_QUEUE_1 = 0,
< 	/* Assert ALERT/RDY after two conversions */
< 	ADS1X1X_CONFIG_COMP_QUEUE_2 = 1,
< 	/* Assert ALERT/RDY after four conversions */
< 	ADS1X1X_CONFIG_COMP_QUEUE_4 = 2,
< 	/* Disable the comparator and put ALERT/RDY in high state (default) */
< 	ADS1X1X_CONFIG_COMP_QUEUE_NONE = 3
< };
---
> 	/* TODO */
> 	if (channel_cfg->acquisition_time != ADC_ACQ_TIME_DEFAULT) {
> 		LOG_ERR("unsupported acquisition_time '%d'",
> 			channel_cfg->acquisition_time);
> 		return -ENOTSUP;
> 	}
125,131c147,153
< struct ads1x1x_config {
< 	struct i2c_dt_spec bus;
< 	const uint32_t odr_delay[8];
< 	uint8_t resolution;
< 	bool multiplexer;
< 	bool pga;
< };
---
> 	/* TODO */
> 	/* ADS1115 supports 2 differential inputs -- not yet implemented */
> 	if (channel_cfg->differential != 0) {
> 		LOG_ERR("unsupported differential '%d'",
> 			channel_cfg->differential);
> 		return -ENOTSUP;
> 	}
133,141c155,158
< struct ads1x1x_data {
< 	const struct device *dev;
< 	struct adc_context ctx;
< 	k_timeout_t ready_time;
< 	struct k_sem acq_sem;
< 	int16_t *buffer;
< 	int16_t *repeat_buffer;
< 	struct k_thread thread;
< 	bool differential;
---
> 	if (channel_cfg->channel_id >= ADS1115_NUM_CHANNELS) {
> 		LOG_ERR("unsupported channel id '%d'", channel_cfg->channel_id);
> 		return -ENOTSUP;
> 	}
143,144c160,161
< 	K_THREAD_STACK_MEMBER(stack, CONFIG_ADC_ADS1X1X_ACQUISITION_THREAD_STACK_SIZE);
< };
---
> 	return 0;
> }
146c163,164
< static int ads1x1x_read_reg(const struct device *dev, enum ads1x1x_reg reg_addr, uint16_t *buf)
---
> static int ads1115_validate_buffer_size(const struct device * dev,
> 					const struct adc_sequence * sequence)
148,150c166,174
< 	const struct ads1x1x_config *config = dev->config;
< 	uint16_t reg_val;
< 	int ret;
---
> 	uint8_t channels = 0;
> 	size_t needed;
> 	uint32_t mask;
> 
> 	for (mask = BIT(ADS1115_NUM_CHANNELS - 1); mask != 0; mask >>= 1) {
> 		if (mask & sequence->channels) {
> 			channels++;
> 		}
> 	}
152,156c176,178
< 	ret = i2c_burst_read_dt(&config->bus, reg_addr, (uint8_t *)&reg_val, sizeof(reg_val));
< 	if (ret != 0) {
< 		LOG_ERR("ADS1X1X[0x%X]: error reading register 0x%X (%d)", config->bus.addr,
< 			reg_addr, ret);
< 		return ret;
---
> 	needed = channels * sizeof(uint16_t);
> 	if (sequence->options) {
> 		needed *= (1 + sequence->options->extra_samplings);
159c181,183
< 	*buf = sys_be16_to_cpu(reg_val);
---
> 	if (sequence->buffer_size < needed) {
> 		return -ENOMEM;
> 	}
164c188,189
< static int ads1x1x_write_reg(const struct device *dev, enum ads1x1x_reg reg_addr, uint16_t reg_val)
---
> static int ads1115_start_read(const struct device * dev,
> 			      const struct adc_sequence * sequence)
166,168c191,192
< 	const struct ads1x1x_config *config = dev->config;
< 	uint8_t buf[3];
< 	int ret;
---
> 	struct ads1115_data * data = dev->data;
> 	int err;
170,171c194,197
< 	buf[0] = reg_addr;
< 	sys_put_be16(reg_val, &buf[1]);
---
> 	if (sequence->resolution != 16) {
> 		LOG_ERR("unsupported resolution %d", sequence->resolution);
> 		return -ENOTSUP;
> 	}
173c199,203
< 	ret = i2c_write_dt(&config->bus, buf, sizeof(buf));
---
> 	if (find_msb_set(sequence->channels) > ADS1115_NUM_CHANNELS) {
> 		LOG_ERR("unsupported channels in mask: 0x%08x",
> 			sequence->channels);
> 		return -ENOTSUP;
> 	}
175,178c205,208
< 	if (ret != 0) {
< 		LOG_ERR("ADS1X1X[0x%X]: error writing register 0x%X (%d)", config->bus.addr,
< 			reg_addr, ret);
< 		return ret;
---
> 	err = ads1115_validate_buffer_size(dev, sequence);
> 	if (err) {
> 		LOG_ERR("buffer size too small");
> 		return err;
181c211,215
< 	return 0;
---
> 	data->buffer = sequence->buffer;
> 	data->oversampling = sequence->oversampling;
> 	adc_context_start_read(&data->ctx, sequence);
> 
> 	return adc_context_wait_for_completion(&data->ctx);
184c218,220
< static int ads1x1x_start_conversion(const struct device *dev)
---
> static int ads1115_read_async(const struct device * dev,
> 			      const struct adc_sequence * sequence,
> 			      struct k_poll_signal * async)
186,187c222,223
< 	/* send start sampling command */
< 	uint16_t config;
---
> 	struct ads1115_data * data = dev->data;
> 	int err;
189,191c225,227
< 	ads1x1x_read_reg(dev, ADS1X1X_REG_CONFIG, &config);
< 	config |= ADS1X1X_CONFIG_OS;
< 	ads1x1x_write_reg(dev, ADS1X1X_REG_CONFIG, config);
---
> 	adc_context_lock(&data->ctx, async ? true : false, async);
> 	err = ads1115_start_read(dev, sequence);
> 	adc_context_release(&data->ctx, err);
193c229
< 	return 0;
---
> 	return err;
196c232,233
< static inline int ads1x1x_acq_time_to_dr(const struct device *dev, uint16_t acq_time)
---
> static int ads1115_read(const struct device * dev,
> 			const struct adc_sequence * sequence)
198,212c235,236
< 	struct ads1x1x_data *data = dev->data;
< 	const struct ads1x1x_config *ads_config = dev->config;
< 	const uint32_t *odr_delay = ads_config->odr_delay;
< 	uint32_t odr_delay_us = 0;
< 	int odr = -EINVAL;
< 	uint16_t acq_value = ADC_ACQ_TIME_VALUE(acq_time);
< 
< 	/* The ADS1x1x uses samples per seconds units with the lowest being 8SPS
< 	 * and with acquisition_time only having 14b for time, this will not fit
< 	 * within here for microsecond units. Use Tick units and allow the user to
< 	 * specify the ODR directly.
< 	 */
< 	if (acq_time != ADC_ACQ_TIME_DEFAULT && ADC_ACQ_TIME_UNIT(acq_time) != ADC_ACQ_TIME_TICKS) {
< 		return -EINVAL;
< 	}
---
> 	return ads1115_read_async(dev, sequence, NULL);
> }
214,254c238,240
< 	if (acq_time == ADC_ACQ_TIME_DEFAULT) {
< 		odr = ADS1X1X_CONFIG_DR_DEFAULT;
< 		odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_DEFAULT];
< 	} else {
< 		switch (acq_value) {
< 		case ADS1X1X_CONFIG_DR_8_128:
< 			odr = ADS1X1X_CONFIG_DR_8_128;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_8_128];
< 			break;
< 		case ADS1X1X_CONFIG_DR_16_250:
< 			odr = ADS1X1X_CONFIG_DR_16_250;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_16_250];
< 			break;
< 		case ADS1X1X_CONFIG_DR_32_490:
< 			odr = ADS1X1X_CONFIG_DR_32_490;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_32_490];
< 			break;
< 		case ADS1X1X_CONFIG_DR_64_920:
< 			odr = ADS1X1X_CONFIG_DR_64_920;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_64_920];
< 			break;
< 		case ADS1X1X_CONFIG_DR_128_1600:
< 			odr = ADS1X1X_CONFIG_DR_128_1600;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_128_1600];
< 			break;
< 		case ADS1X1X_CONFIG_DR_250_2400:
< 			odr = ADS1X1X_CONFIG_DR_250_2400;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_250_2400];
< 			break;
< 		case ADS1X1X_CONFIG_DR_475_3300:
< 			odr = ADS1X1X_CONFIG_DR_475_3300;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_475_3300];
< 			break;
< 		case ADS1X1X_CONFIG_DR_860_3300:
< 			odr = ADS1X1X_CONFIG_DR_860_3300;
< 			odr_delay_us = odr_delay[ADS1X1X_CONFIG_DR_860_3300];
< 			break;
< 		default:
< 			break;
< 		}
< 	}
---
> static void adc_context_start_sampling(struct adc_context * ctx)
> {
> 	struct ads1115_data * data = CONTAINER_OF(ctx, struct ads1115_data, ctx);
256,259c242,243
< 	/* As per the datasheet, 25us is needed to wake-up from power down mode
< 	 */
< 	odr_delay_us += 25;
< 	data->ready_time = K_USEC(odr_delay_us);
---
> 	data->seq_channels = ctx->sequence.channels;
> 	data->repeat_buffer = data->buffer;
261c245
< 	return odr;
---
> 	k_sem_give(&data->sem);
264c248,249
< static int ads1x1x_wait_data_ready(const struct device *dev)
---
> static void adc_context_update_buffer_pointer(struct adc_context * ctx,
> 					      bool repeat_sampling)
266,275c251
< 	int rc;
< 	struct ads1x1x_data *data = dev->data;
< 
< 	k_sleep(data->ready_time);
< 	uint16_t status = 0;
< 
< 	rc = ads1x1x_read_reg(dev, ADS1X1X_REG_CONFIG, &status);
< 	if (rc != 0) {
< 		return rc;
< 	}
---
> 	struct ads1115_data * data = CONTAINER_OF(ctx, struct ads1115_data, ctx);
277,282c253,254
< 	while (!(status & ADS1X1X_CONFIG_OS)) {
< 		k_sleep(K_USEC(100));
< 		rc = ads1x1x_read_reg(dev, ADS1X1X_REG_CONFIG, &status);
< 		if (rc != 0) {
< 			return rc;
< 		}
---
> 	if (repeat_sampling) {
> 		data->buffer = data->repeat_buffer;
284,285d255
< 
< 	return rc;
288,289c258,261
< static int ads1x1x_channel_setup(const struct device *dev,
< 				 const struct adc_channel_cfg *channel_cfg)
---
> /* Called within acquisition thread to read an individual sample */
> /* Can return -EAGAIN if sample is not ready */
> static int ads1115_read_channel(struct ads1115_data * data, uint8_t channel,
> 				uint16_t *result)
291,299c263,264
< 	const struct ads1x1x_config *ads_config = dev->config;
< 	struct ads1x1x_data *data = dev->data;
< 	uint16_t config = 0;
< 	int dr = 0;
< 
< 	if (channel_cfg->channel_id != 0) {
< 		LOG_ERR("unsupported channel id '%d'", channel_cfg->channel_id);
< 		return -ENOTSUP;
< 	}
---
> 	int status = false;
> 	int err = 0;
301,303c266,268
< 	if (channel_cfg->reference != ADC_REF_INTERNAL) {
< 		LOG_ERR("unsupported channel reference type '%d'", channel_cfg->reference);
< 		return -ENOTSUP;
---
> 	if(channel >= ADS1115_NUM_CHANNELS) {
> 		LOG_ERR("Invalid sampling channel");
> 		return -EINVAL;
306,346c271,276
< 	if (ads_config->multiplexer) {
< 		/* the device has an input multiplexer */
< 		if (channel_cfg->differential) {
< 			if (channel_cfg->input_positive == 0 && channel_cfg->input_negative == 1) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_DIFF_0_1);
< 			} else if (channel_cfg->input_positive == 0 &&
< 				   channel_cfg->input_negative == 3) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_DIFF_0_3);
< 			} else if (channel_cfg->input_positive == 1 &&
< 				   channel_cfg->input_negative == 3) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_DIFF_1_3);
< 			} else if (channel_cfg->input_positive == 2 &&
< 				   channel_cfg->input_negative == 3) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_DIFF_2_3);
< 			} else {
< 				LOG_ERR("unsupported input positive '%d' and input negative '%d'",
< 					channel_cfg->input_positive, channel_cfg->input_negative);
< 				return -ENOTSUP;
< 			}
< 		} else {
< 			if (channel_cfg->input_positive == 0) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_SINGLE_0);
< 			} else if (channel_cfg->input_positive == 1) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_SINGLE_1);
< 			} else if (channel_cfg->input_positive == 2) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_SINGLE_2);
< 			} else if (channel_cfg->input_positive == 3) {
< 				config |= ADS1X1X_CONFIG_MUX(ADS1X15_CONFIG_MUX_SINGLE_3);
< 			} else {
< 				LOG_ERR("unsupported input positive '%d'",
< 					channel_cfg->input_positive);
< 				return -ENOTSUP;
< 			}
< 		}
< 	} else {
< 		/* only differential supported without multiplexer */
< 		if (!((channel_cfg->differential) &&
< 		      (channel_cfg->input_positive == 0 && channel_cfg->input_negative == 1))) {
< 			LOG_ERR("unsupported input positive '%d' and input negative '%d'",
< 				channel_cfg->input_positive, channel_cfg->input_negative);
< 			return -ENOTSUP;
---
> 	if(!data->active) {
> 		//LOG_DBG("Starting fetching sample");
> 		err = ads1115_chan_change_with_start_conversion(data, channel);
> 		if(err) {
> 			LOG_ERR("Error starting conversion");
> 			return err;
348,350d277
< 	}
< 	/* store differential mode to determine supported resolution */
< 	data->differential = channel_cfg->differential;
352,356c279,280
< 	dr = ads1x1x_acq_time_to_dr(dev, channel_cfg->acquisition_time);
< 	if (dr < 0) {
< 		LOG_ERR("unsupported channel acquisition time 0x%02x",
< 			channel_cfg->acquisition_time);
< 		return -ENOTSUP;
---
> 		data->active = true;
> 		data->active_channel = channel;
359,391c283,286
< 	config |= ADS1X1X_CONFIG_DR(dr);
< 
< 	if (ads_config->pga) {
< 		/* programmable gain amplifier support */
< 		switch (channel_cfg->gain) {
< 		case ADC_GAIN_1_3:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_6144);
< 			break;
< 		case ADC_GAIN_1_2:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_4096);
< 			break;
< 		case ADC_GAIN_1:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_2048);
< 			break;
< 		case ADC_GAIN_2:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_1024);
< 			break;
< 		case ADC_GAIN_4:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_512);
< 			break;
< 		case ADC_GAIN_8:
< 			config |= ADS1X1X_CONFIG_PGA(ADS1X1X_CONFIG_PGA_256);
< 			break;
< 		default:
< 			LOG_ERR("unsupported channel gain '%d'", channel_cfg->gain);
< 			return -ENOTSUP;
< 		}
< 	} else {
< 		/* no programmable gain amplifier, so only allow ADC_GAIN_1 */
< 		if (channel_cfg->gain != ADC_GAIN_1) {
< 			LOG_ERR("unsupported channel gain '%d'", channel_cfg->gain);
< 			return -ENOTSUP;
< 		}
---
> 	if(channel != data->active_channel) {
> 		LOG_ERR("Conversion active on channel %d, but requested on %d",
> 			data->active_channel, channel);
> 		return -EBUSY;
394,405c289,293
< 	/* Only single shot supported */
< 	config |= ADS1X1X_CONFIG_MODE;
< 
< 	/* disable comparator */
< 	config |= ADS1X1X_CONFIG_COMP_MODE;
< 
< 	return ads1x1x_write_reg(dev, ADS1X1X_REG_CONFIG, config);
< }
< 
< static int ads1x1x_validate_buffer_size(const struct adc_sequence *sequence)
< {
< 	size_t needed = sizeof(int16_t);
---
> 	err = ads1115_once_conversion_status_get(data, &status);
> 	if(err) {
> 		LOG_ERR("Error checking status");
> 		return err;
> 	}
407,408c295,296
< 	if (sequence->options) {
< 		needed *= (1 + sequence->options->extra_samplings);
---
> 	if(!status) {
> 		return -EAGAIN;
411,412c299,302
< 	if (sequence->buffer_size < needed) {
< 		return -ENOMEM;
---
> 	err = ads1115_reg_read(data, ADS1115_REG_CONVERSION, result);
> 	if(err) {
> 		LOG_ERR("Error fetching sample");
> 		return err;
414a305,307
> 	data->active = false;
> 	//LOG_DBG("Completed fetching sample %d", *result);
> 
418c311
< static int ads1x1x_validate_sequence(const struct device *dev, const struct adc_sequence *sequence)
---
> static void ads1115_acquisition_thread(struct ads1115_data *data)
420,422c313,314
< 	const struct ads1x1x_config *config = dev->config;
< 	struct ads1x1x_data *data = dev->data;
< 	uint8_t resolution = data->differential ? config->resolution : config->resolution - 1;
---
> 	uint16_t result = 0;
> 	uint8_t channel;
423a316,319
> 	uint16_t needed;
> 	uint16_t valid;
> 	uint16_t samples;
> 	uint64_t acc;
425,433c321,322
< 	if (sequence->resolution != resolution) {
< 		LOG_ERR("unsupported resolution %d", sequence->resolution);
< 		return -ENOTSUP;
< 	}
< 
< 	if (sequence->channels != BIT(0)) {
< 		LOG_ERR("only channel 0 supported");
< 		return -ENOTSUP;
< 	}
---
> 	while (true) {
> 		k_sem_take(&data->sem, K_FOREVER);
435,438c324,370
< 	if (sequence->oversampling) {
< 		LOG_ERR("oversampling not supported");
< 		return -ENOTSUP;
< 	}
---
> 		acc = 0;
> 		samples = 0;
> 		valid = 0;
> 		needed = 1 << data->oversampling;
> 
> 		while (data->seq_channels) {
> 			channel = find_lsb_set(data->seq_channels) - 1;
> 
> 			//LOG_DBG("Reading channel %d", channel);
> 
> 			err = ads1115_read_channel(data, channel, &result);
> 			if (err == -EAGAIN) {
> 				//LOG_DBG("Channel %d not yet ready", channel);
> 				/* Lie to adc_context_request_next_sampling to get back here */
> 				atomic_set(&data->ctx.sampling_requested, 0);
> 				k_sem_take(&data->sem, K_FOREVER);
> 			}
> 			else if (err) {
> 				LOG_ERR("failed to read channel %d (err %d)",
> 					channel, err);
> 				adc_context_complete(&data->ctx, err);
> 				break;
> 			} else {
> 				samples++;
> 			       	/* TODO: create good threshold attribute */
> 				//if(result > 10 && result < 0xfff0) {
> 				if(result < 0xfff0) {
> 					valid++;
> 					acc += result*result;
> 				}
> 				if (samples >= needed) {
> 					LOG_DBG("read channel %d, result = %d, acc = %ld", channel,
> 						result, (long)acc);
> 					if (needed > 1) {
> 						acc /= valid;
> 						*data->buffer++ = sqrt(acc);
> 					} else {
> 						*data->buffer++ = result;
> 					}
> 					WRITE_BIT(data->seq_channels, channel, 0);
> 
> 					acc = 0;
> 					samples = 0;
> 					valid = 0;
> 				}
> 			}
> 		}
440,443c372
< 	err = ads1x1x_validate_buffer_size(sequence);
< 	if (err) {
< 		LOG_ERR("buffer size too small");
< 		return -ENOTSUP;
---
> 		adc_context_on_sampling_done(&data->ctx, data->dev);
445,446d373
< 
< 	return 0;
449c376,378
< static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)
---
> /*
> static void ads1115_gpio_callback(const struct device * dev,
> 				  struct gpio_callback * cb, uint32_t pins)
451c380,381
< 	struct ads1x1x_data *data = CONTAINER_OF(ctx, struct ads1x1x_data, ctx);
---
> 	struct ads1115_data * data = dev->data;
> 	const struct ads1115_config * config = dev->config;
453,455c383,387
< 	if (repeat_sampling) {
< 		data->buffer = data->repeat_buffer;
< 	}
---
> 	ARG_UNUSED(cb);
> 	ARG_UNUSED(pins);
> 
> 	gpio_pin_interrupt_configure_dt(&config->int_gpio, GPIO_INT_DISABLE);
> 	k_sem_give(&data->sem);
456a389
> */
458c391
< static void adc_context_start_sampling(struct adc_context *ctx)
---
> static int ads1115_reg_write(struct ads1115_data * data, uint8_t reg, uint16_t * val)
460,462c393
< 	struct ads1x1x_data *data = CONTAINER_OF(ctx, struct ads1x1x_data, ctx);
< 
< 	data->repeat_buffer = data->buffer;
---
> 	int err = 0;
464c395,396
< 	ads1x1x_start_conversion(data->dev);
---
> 	uint8_t wr_buff[3] = {0};
> 	uint16_t wr_value = *val;
466,467c398,400
< 	k_sem_give(&data->acq_sem);
< }
---
> 	wr_buff[0] = reg;
> 	wr_buff[1] = (wr_value >> 8) & 0xff;
> 	wr_buff[2] = wr_value & 0xff;
469,472c402
< static int ads1x1x_adc_start_read(const struct device *dev, const struct adc_sequence *sequence)
< {
< 	int rc;
< 	struct ads1x1x_data *data = dev->data;
---
> 	err = i2c_write_dt(&data->cfg->bus, wr_buff, 3);
474,476c404,406
< 	rc = ads1x1x_validate_sequence(dev, sequence);
< 	if (rc != 0) {
< 		return rc;
---
> 	if (err < 0) {
> 		LOG_ERR("Error writing %d to reg 0x%02x", err, reg);
> 		return err;
479,483c409
< 	data->buffer = sequence->buffer;
< 
< 	adc_context_start_read(&data->ctx, sequence);
< 
< 	return adc_context_wait_for_completion(&data->ctx);
---
> 	return 0;
486,487c412
< static int ads1x1x_adc_read_async(const struct device *dev, const struct adc_sequence *sequence,
< 				  struct k_poll_signal *async)
---
> static int ads1115_reg_read(struct ads1115_data * data, uint8_t reg, uint16_t * val)
489,490c414
< 	int rc;
< 	struct ads1x1x_data *data = dev->data;
---
> 	int err = 0;
492,494c416,417
< 	adc_context_lock(&data->ctx, async ? true : false, async);
< 	rc = ads1x1x_adc_start_read(dev, sequence);
< 	adc_context_release(&data->ctx, rc);
---
> 	uint8_t wr_buff[1] = {0};
> 	uint8_t rd_buff[2] = {0};
496c419,430
< 	return rc;
---
> 	wr_buff[0] = reg;
> 
> 	err = i2c_write_read_dt(&data->cfg->bus, wr_buff, 1, rd_buff, 2);
> 	if (err < 0) {
> 		LOG_ERR("Error writing %d to reg 0x%02x", err, reg);
> 		return err;
> 	}
> 
> 	*val = (uint16_t)rd_buff[0] << 8;
> 	*val |= rd_buff[1];
> 
> 	return 0;
499c433
< static int ads1x1x_adc_perform_read(const struct device *dev)
---
> static int ads1115_chan_change_with_start_conversion(struct ads1115_data * data, uint8_t channel)
501,504c435
< 	int rc;
< 	struct ads1x1x_data *data = dev->data;
< 	const struct ads1x1x_config *config = dev->config;
< 	int16_t buf;
---
> 	int err = 0;
506,509c437,440
< 	rc = ads1x1x_read_reg(dev, ADS1X1X_REG_CONV, &buf);
< 	if (rc != 0) {
< 		adc_context_complete(&data->ctx, rc);
< 		return rc;
---
> 	if(channel >= ADS1115_NUM_CHANNELS)
> 	{
> 		LOG_ERR("Invalid channel %d", channel);
> 		return -EINVAL;
511,516d441
< 	/* The ads101x stores it's 12b data in the upper part
< 	 * while the ads111x uses all 16b in the register, so
< 	 * shift down. Data is also signed, so perform
< 	 * division rather than shifting
< 	 */
< 	*data->buffer++ = buf / (1 << (16 - config->resolution));
518c443,444
< 	adc_context_on_sampling_done(&data->ctx, dev);
---
> 	ADS1115_CFG_MUX_SET(4 + channel);
> 	ADS1115_CFG_OS_SET(1);
520,521c446,451
< 	return rc;
< }
---
> 	//LOG_DBG("Writing to config reg 0x%02x", data->config_reg);
> 	err = ads1115_reg_write(data, ADS1115_REG_CONFIG, &data->config_reg);
> 	if(err < 0)
> 	{
> 		return -EINVAL;
> 	}
523,525c453
< static int ads1x1x_read(const struct device *dev, const struct adc_sequence *sequence)
< {
< 	return ads1x1x_adc_read_async(dev, sequence, NULL);
---
> 	return 0;
528c456
< static void ads1x1x_acquisition_thread(const struct device *dev)
---
> static int ads1115_once_conversion_status_get(struct ads1115_data * data, int * status)
530,531c458
< 	struct ads1x1x_data *data = dev->data;
< 	int rc;
---
> 	int err = 0;
533,534c460,464
< 	while (true) {
< 		k_sem_take(&data->acq_sem, K_FOREVER);
---
> 	err = ads1115_reg_read(data, ADS1115_REG_CONFIG, &data->config_reg);
> 	if(err < 0)
> 	{
> 		return -EINVAL;
> 	}
536,541c466
< 		rc = ads1x1x_wait_data_ready(dev);
< 		if (rc != 0) {
< 			LOG_ERR("failed to get ready status (err %d)", rc);
< 			adc_context_complete(&data->ctx, rc);
< 			break;
< 		}
---
> 	*status = ADS1115_CFG_OS_GET();
543,544c468
< 		ads1x1x_adc_perform_read(dev);
< 	}
---
> 	return 0;
547c471
< static int ads1x1x_init(const struct device *dev)
---
> static int ads1115_init(const struct device *dev)
549,550c473,475
< 	const struct ads1x1x_config *config = dev->config;
< 	struct ads1x1x_data *data = dev->data;
---
> 	const struct ads1115_config * config = dev->config;
> 	struct ads1115_data * data = dev->data;
> 	int err = 0;
552c477
< 	data->dev = dev;
---
> 	data->cfg = config;
554c479
< 	k_sem_init(&data->acq_sem, 0, 1);
---
> 	k_sem_init(&data->sem, 0, 1);
557c482
< 		LOG_ERR("I2C bus %s not ready", config->bus.bus->name);
---
> 		LOG_ERR("I2C bus is not ready");
561,565c486,487
< 	const k_tid_t tid =
< 		k_thread_create(&data->thread, data->stack, K_THREAD_STACK_SIZEOF(data->stack),
< 				(k_thread_entry_t)ads1x1x_acquisition_thread, (void *)dev, NULL,
< 				NULL, CONFIG_ADC_ADS1X1X_ACQUISITION_THREAD_PRIO, 0, K_NO_WAIT);
< 	k_thread_name_set(tid, "adc_ads1x1x");
---
> 	/* Try 100ms delay at the start */
> 	k_msleep(100);
567,606c489,494
< 	adc_context_unlock_unconditionally(&data->ctx);
< 
< 	return 0;
< }
< 
< static const struct adc_driver_api ads1x1x_api = {
< 	.channel_setup = ads1x1x_channel_setup,
< 	.read = ads1x1x_read,
< 	.ref_internal = 2048,
< #ifdef CONFIG_ADC_ASYNC
< 	.read_async = ads1x1x_adc_read_async,
< #endif
< };
< 
< #define DT_INST_ADS1X1X(inst, t) DT_INST(inst, ti_ads##t)
< 
< #define ADS1X1X_INIT(t, n, odr_delay_us, res, mux, pgab)                                           \
< 	static const struct ads1x1x_config ads##t##_config_##n = {                                 \
< 		.bus = I2C_DT_SPEC_GET(DT_INST_ADS1X1X(n, t)),                                     \
< 		.odr_delay = odr_delay_us,                                                         \
< 		.resolution = res,                                                                 \
< 		.multiplexer = mux,                                                                \
< 		.pga = pgab,                                                                       \
< 	};                                                                                         \
< 	static struct ads1x1x_data ads##t##_data_##n = {                                           \
< 		ADC_CONTEXT_INIT_LOCK(ads##t##_data_##n, ctx),                                     \
< 		ADC_CONTEXT_INIT_TIMER(ads##t##_data_##n, ctx),                                    \
< 		ADC_CONTEXT_INIT_SYNC(ads##t##_data_##n, ctx),                                     \
< 	};                                                                                         \
< 	DEVICE_DT_DEFINE(DT_INST_ADS1X1X(n, t), ads1x1x_init, NULL, &ads##t##_data_##n,            \
< 			 &ads##t##_config_##n, POST_KERNEL, CONFIG_ADC_ADS1X1X_INIT_PRIORITY,      \
< 			 &ads1x1x_api);
< 
< /* The ADS111X provides 16 bits of data in binary two's complement format
<  * A positive full-scale (+FS) input produces an output code of 7FFFh and a
<  * negative full-scale (–FS) input produces an output code of 8000h. Single
<  * ended signal measurements only only use the positive code range from
<  * 0000h to 7FFFh
<  */
< #define ADS111X_RESOLUTION 16
---
> 	err = ads1115_reg_read(data, ADS1115_REG_CONFIG, &data->config_reg);
> 	if(err < 0)
> 	{
> 		LOG_ERR("Unable to read config register");
> 		return -EINVAL;
> 	}
608,615c496,513
< /*
<  * Approximated ADS111x acquisition times in microseconds. These are
<  * used for the initial delay when polling for data ready.
<  * {8 SPS, 16 SPS, 32 SPS, 64 SPS, 128 SPS (default), 250 SPS, 475 SPS, 860 SPS}
<  */
< #define ADS111X_ODR_DELAY_US                                                                       \
< 	{                                                                                          \
< 		125000, 62500, 31250, 15625, 7813, 4000, 2105, 1163                                \
---
> 	ADS1115_CFG_OS_SET(0);		/* OS = No conversion start */
> 	ADS1115_CFG_MUX_SET(4);		/* MUX = 100b: AINp = AIN0 and AINn = GND */
> 	ADS1115_CFG_PGA_SET(1);		/* PGA = 001b: FSR = 4.096V */
> 	if(config->continuous_mode)
> 		ADS1115_CFG_MODE_SET(0);/* MODE = 0: Continuous-conversion mode */
> 	else
> 		ADS1115_CFG_MODE_SET(1);/* MODE = 1: Single-shot mode or power-down state */
> 	//ADS1115_CFG_DR_SET(5);		/* DR = 101b: 250 samples per second */
> 	ADS1115_CFG_DR_SET(6);		/* DR = 110b: 475 samples per second */
> 	ADS1115_CFG_CM_SET(0);		/* COMP_MODE = 0: Traditional comparator */
> 	ADS1115_CFG_CP_SET(1);		/* COMP_POL = 1: Active high polarity */
> 	ADS1115_CFG_CL_SET(0);		/* COMP_LAT = 0: Nonlatching comparator */
> 	ADS1115_CFG_CQ_SET(3);		/* COMP_QUE = 11b: Disable comparator */
> 	err = ads1115_reg_write(data, ADS1115_REG_CONFIG, &data->config_reg);
> 	if(err < 0)
> 	{
> 		LOG_ERR("Unable to write config register");
> 		return -EINVAL;
618,624c516,521
< /*
<  * ADS1115: 16 bit, multiplexer, programmable gain amplifier
<  */
< #define ADS1115_INIT(n) ADS1X1X_INIT(1115, n, ADS111X_ODR_DELAY_US, ADS111X_RESOLUTION, true, true)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1115
< DT_INST_FOREACH_STATUS_OKAY(ADS1115_INIT)
---
> 	k_thread_create(&data->thread, data->stack,
> 			CONFIG_ADC_ADS1115_ACQUISITION_THREAD_STACK_SIZE,
> 			(k_thread_entry_t)ads1115_acquisition_thread,
> 			data, NULL, NULL,
> 			CONFIG_ADC_ADS1115_ACQUISITION_THREAD_PRIO,
> 			0, K_NO_WAIT);
626,632c523
< /*
<  * ADS1114: 16 bit, no multiplexer, programmable gain amplifier
<  */
< #define ADS1114_INIT(n) ADS1X1X_INIT(1114, n, ADS111X_ODR_DELAY_US, ADS111X_RESOLUTION, false, true)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1114
< DT_INST_FOREACH_STATUS_OKAY(ADS1114_INIT)
---
> 	adc_context_unlock_unconditionally(&data->ctx);
634,649c525,526
< /*
<  * ADS1113: 16 bit, no multiplexer, no programmable gain amplifier
<  */
< #define ADS1113_INIT(n)                                                                            \
< 	ADS1X1X_INIT(1113, n, ADS111X_ODR_DELAY_US, ADS111X_RESOLUTION, false, false)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1113
< DT_INST_FOREACH_STATUS_OKAY(ADS1113_INIT)
< 
< /* The ADS101X provides 12 bits of data in binary two's complement format
<  * A positive full-scale (+FS) input produces an output code of 7FFh and a
<  * negative full-scale (–FS) input produces an output code of 800h. Single
<  * ended signal measurements only only use the positive code range from
<  * 000h to 7FFh
<  */
< #define ADS101X_RESOLUTION 12
---
> 	return 0;
> }
651,659c528,529
< /*
<  * Approximated ADS101x acquisition times in microseconds. These are
<  * used for the initial delay when polling for data ready.
<  * {128 SPS, 250 SPS, 490 SPS, 920 SPS, 1600 SPS (default), 2400 SPS, 3300 SPS, 3300 SPS}
<  */
< #define ADS101X_ODR_DELAY_US                                                                       \
< 	{                                                                                          \
< 		7813, 4000, 2041, 1087, 625, 417, 303, 303                                         \
< 	}
---
> #define ADS1115_DEV(inst) DT_INST(inst, DT_DRV_COMPAT)
> #define ADS1115_PROP(inst, prop) DT_PROP(DT_INST(inst, DT_DRV_COMPAT), prop)
661,667c531,554
< /*
<  * ADS1015: 12 bit, multiplexer, programmable gain amplifier
<  */
< #define ADS1015_INIT(n) ADS1X1X_INIT(1015, n, ADS101X_ODR_DELAY_US, ADS101X_RESOLUTION, true, true)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1015
< DT_INST_FOREACH_STATUS_OKAY(ADS1015_INIT)
---
> #define DEFINE_ADS1115(inst)						\
> 									\
> static const struct ads1115_config ads1115_config_##inst = {		\
> 	.bus = I2C_DT_SPEC_INST_GET(inst),				\
> 	.continuous_mode = ADS1115_PROP(inst,continuous_mode),		\
> 	.int_gpio = GPIO_DT_SPEC_GET_OR(ADS1115_DEV(inst), int_gpios, {.port=NULL}),	\
> };									\
> 									\
> static struct ads1115_data ads1115_data_##inst = {			\
> 	ADC_CONTEXT_INIT_TIMER(ads1115_data_##inst, ctx), 		\
> 	ADC_CONTEXT_INIT_LOCK(ads1115_data_##inst, ctx),		\
> 	ADC_CONTEXT_INIT_SYNC(ads1115_data_##inst, ctx),		\
> 	.active = false,						\
> 	.cfg = &ads1115_config_##inst,					\
> };									\
> 									\
> DEVICE_DT_INST_DEFINE(inst,						\
> 		ads1115_init,						\
> 		device_pm_control_nop,					\
> 		&ads1115_data_##inst,					\
> 		&ads1115_config_##inst,					\
> 		POST_KERNEL,						\
> 		CONFIG_SENSOR_INIT_PRIORITY,				\
> 		&ads1115_api_funcs);
670,675c557,558
<  * ADS1014: 12 bit, no multiplexer, programmable gain amplifier
<  */
< #define ADS1014_INIT(n) ADS1X1X_INIT(1014, n, ADS101X_ODR_DELAY_US, ADS101X_RESOLUTION, false, true)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1014
< DT_INST_FOREACH_STATUS_OKAY(ADS1014_INIT)
---
> 	.avg_method = ADS1115_PROP(inst,avg_method),			\
> */
677,684c560
< /*
<  * ADS1013: 12 bit, no multiplexer, no programmable gain amplifier
<  */
< #define ADS1013_INIT(n)                                                                            \
< 	ADS1X1X_INIT(1013, n, ADS101X_ODR_DELAY_US, ADS101X_RESOLUTION, false, false)
< #undef DT_DRV_COMPAT
< #define DT_DRV_COMPAT ti_ads1013
< DT_INST_FOREACH_STATUS_OKAY(ADS1013_INIT)
---
> DT_INST_FOREACH_STATUS_OKAY(DEFINE_ADS1115)
